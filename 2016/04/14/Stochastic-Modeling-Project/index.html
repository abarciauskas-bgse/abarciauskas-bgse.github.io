<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script type="text/javascript" src="http://d3js.org/d3.v3.js" charset="utf-8"></script><script type="text/javascript" src="/javascripts/d3.tip.js"></script><script type="text/javascript" src="/javascripts/columnChart.js"></script><script type="text/javascript" src="http://numericjs.com/numeric/lib/numeric-1.2.6.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/jstat/1.5.2/jstat.min.js"></script><script type="text/javascript" src="https://protobi.com/examples/pca/pca.js"></script><title> Stochastic Modeling Project · Aimee Barciauskas</title><meta name="description" content="Stochastic Modeling Project - Aimee Barciauskas"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600"></head><body><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abarciauskas-bgse" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Stochastic Modeling Project</h1><div class="post-time">Apr 14, 2016</div><div class="post-content"><script type="text/javascript" src="/js/d3.layout.js"></script>
<script type="text/javascript" src="/js/colorbrewer.js"></script>
<script type="text/javascript" src="http://underscorejs.org/underscore.js"></script>

<style type="text/css">

  body {
    background: #222;
    color: white;
    font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
    font-size: 18px;
  }

  a {
    color: orange;
  }
  .node circle {
    cursor: pointer;
    /*fill: #fff;*/
    stroke: steel ;
    stroke-width: 1.5px;
  }

  .node text {
    font-size: 16px;
  }

  path.link {
    fill: none;
    stroke: #666;
    stroke-width: 1.5px;
  }

  svg {
    margin: 0px auto;
    display: block;
  }

  rect.nodeHover {
    fill: "aliceblue";
  }

</style>

<div id="body" class="content"><br><h1>Applications of the Viterbi Algorithm</h1><p>The Viterbi Algorithm is being used to solve Hidden Markov Models and Partially-Observable Markov Decision Processes in the real world.</p><p>The Viterbi Algorithm is a dynamic programming algorithm which solves for the most likely path of a sequential process given a series of observations. It is similar to a shortest path algorithm in that it finds the “least” cost path in it the back-solve phase. The most likely location at time = k can be used to find the most likely path up to time k. So at time N the whole problem can be solved because each subproblem is already optimal.</p><p>Below are examples of how the Viterbi may be used for autonomous robot navigation and speech recognition.</p><p>All the code can be found <a href="https://github.com/abarciauskas-bgse/stochastic/tree/master/project" target="_blank" rel="external">on github.</a></p><p>Anther real-world but less-intuitive application of the Viterbi Algorithm not covered here is in <a href="https://en.wikipedia.org/wiki/Convolutional_code" target="_blank" rel="external">convolutional coding</a>, which is being used in <a href="https://en.wikipedia.org/wiki/Voyager_program" target="_blank" rel="external">spacecraft telemetry.</a></p></div>

<div class="content"><br>  <h1>Resources</h1><ul><li><a href="http://idm-lab.org/bib/abstracts/papers/book98.pdf" target="_blank" rel="external">Xavier: A Robot Navigation Architecture Based on Partially Observable Markov Decision Process Models</a></li><li><a href="http://www.scribd.com/doc/56150380/Dynamic-Programming-and-Optimal-Control-Vol-I#scribd" target="_blank" rel="external"><em>Dynamic Programming and Optimal Control Volume I (Section 2.2),</em>, Dimitri P. Bertseka</a></li><li><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="external">The Viterbi Algorithm</a></li><li><a href="http://www.deepsky.com/~merovech/voynich/voynich_manchu_reference_materials/PDFs/jurafsky_martin.pdf" target="_blank" rel="external"><em>Speech and Language Processing (Section 5.9),</em> Daniel Jurafsky and James H. Martin</a></li><li><a href="https://www.udacity.com/course/viewer#!/c-cs373/l-48646841/m-48667984" target="_blank" rel="external">Udacity: Artificial Intelligence for Robotics</a></li><br>  </ul><br></div>

<script type="text/javascript">
  var m = [100, 0, 20, 5],
      w = 680 - m[1] - m[3],
      h = 800 - m[0] - m[2],
      i = 0,
      root;

  var tree = d3.layout.tree()
      .size([h, w]);

  var diagonal = d3.svg.diagonal()
      .projection(function(d) { return [d.y, d.x]; });

  var vis = d3.select("#body").append("svg:svg")
      .attr("width", w + m[1] + m[3])
      .attr("height", 2200)
    .append("svg:g")
      .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

  var o = d3.scale.ordinal()
    .domain([0,0.001])
    .range(colorbrewer.YlOrRd[6].reverse());

  var o2 = d3.scale.ordinal()
    .domain([0.1,0.2,0.8])
    .range(colorbrewer.OrRd[3]);

  var cell_ht = 50
  var topmargin = 20

  drawMap = function(map, topmargin) {
    map.enter().append('svg:rect')
      .attr('class', 'cell')
      .attr('x', function(d) { return(d[1]*cell_ht)})
      .attr('y', function(d) { return(d[0]*cell_ht+topmargin)})
      .attr("width", cell_ht)
      .attr("height", cell_ht)
      .attr('stroke','#333')
      .attr('fill', function(d) {
        if (d[2] == 99) {
          return('grey')
        } else {
          return('black')
        }
      })
  }

  var speech_group = vis.append("svg:g").attr('id','speech_group')
              .attr("transform", "translate(" + 0 + "," + 1000 + ")");

  d3.json('/js/path.json', function(json) {
    var robot = vis.selectAll('circle').data([json[0]]);

    vis.append("svg:text")
        .text('Autonomous Robot Navigation')
        .style('font-size', '36px')
        .style('fill', 'white')
        .style("fill-opacity", 1);

    d3.json('/js/transitions_matrix.json', function(transitions) {
      d3.json('/js/map.json', function(map) {

        vis.append("svg:text")
            .text('We start with a simplified office map.')
            .attr('x', cell_ht*4+20)
            .attr('y', topmargin+16)
            .style('font-size', '16px')
            .style('fill', 'white');

        var map = vis.selectAll('rect.cell').data(map)

        // original map
        drawMap(map, topmargin)

        topmargin = 4*cell_ht + topmargin + 40

        // map with optimum path
        drawMap(map, topmargin)

        map.enter().append('svg:text')
          .attr('class', 'cell')
          .attr('x', function(d) { return(d[1]*cell_ht + cell_ht/2-4)})
          .attr('y', function(d) { return(d[0]*cell_ht+topmargin + cell_ht/2+5)})
          .attr('fill', 'white')
          .text(function(d) { if (d[2] != 99) { return(d[2])}})

        vis.append("svg:text")
            .text('We give the robot a set of instructions to move in direction of "least cost".')
            .attr('x', cell_ht*4+20)
            .attr('y', topmargin+16)
            .style('font-size', '16px')
            .style('fill', 'white');

        topmargin = 4*cell_ht + topmargin + 40

        // map with transitions
        map.enter().append('svg:rect')
          .attr('class', 'cell')
          .attr('x', function(d) { return(d[1]*cell_ht)})
          .attr('y', function(d) { return(d[0]*cell_ht+topmargin)})
          .attr("width", cell_ht)
          .attr("height", cell_ht)
          .attr('stroke','#333')
          .attr('fill', function(d) {
            if (d[2] == 99) {
              return('grey')
            } else {
              return('black')
            }
          })              
          .on('mouseout', function(d) {
             d3.selectAll('.tempcell').remove()
             d3.selectAll('.temptext').remove()
             d3.select(this).attr('fill',function(d) {
                if (d[2] == 99) {
                  return('grey')
                } else {
                  return('black')
                }                    
              }).style('opacity',1)
          })
          .on('mouseover', function(d) {
            d3.select(this)
              .attr('fill','grey')
              .style('opacity',0.2)
            var loc = '(' + d[0]+', '+d[1]
            var keys_for_cell = _.filter(_.keys(transitions), function(key){
               return key.indexOf(loc) > -1
            });

            // now list all the possible transitions
            keys_for_cell.forEach(function(k) {
              good_transitions = _.pick(transitions[k], function(value, key, object) {
                return value > 0.0;
              });

              // for every possible transition, highlight the cell
              _.keys(good_transitions).forEach(function(key) {
                positions = _.map(key.replace('(','').replace(')','').split(', '), function(n) {return parseInt(n)})
                x = positions[1]
                y = positions[0]

                map.enter().append('svg:rect')
                  .attr('class', 'tempcell')
                  .attr('x', x*cell_ht)
                  .attr('y', y*cell_ht+topmargin)
                  .attr("width", cell_ht)
                  .attr("height", cell_ht)
                  .attr('fill', o2(good_transitions[key]))
                  .attr('opacity',0.1)

                if (d3.selectAll('.temptext')[0].length == 0) {
                  _.values(good_transitions).forEach(function(prob,i) {
                    vis.append("svg:text")
                      .attr('class','temptext')
                      .text(prob)
                      .attr('x', cell_ht*4+20)
                      .attr('y', topmargin+66+i*22)
                      .style('font-size', '16px')
                      .style('fill', 'white');   
                  })        
                }           
              })
            })
          });

          vis.append("svg:text")
            .text('We have a probabilistic belief about what steps the robot may take.')
            .attr('x', cell_ht*4+20)
            .attr('y', topmargin+16)
            .style('font-size', '16px')
            .style('fill', 'white');

          vis.append("svg:text")
            .text('Hover over a cell to see what transitions are most likely.')
            .attr('x', cell_ht*4+20)
            .attr('y', topmargin+38)
            .style('font-size', '16px')
            .style('fill', 'yellow');

          map.enter().append('svg:rect')
            .attr('class', 'cell')
            .attr('x', function(d) { return(d[1]*cell_ht)})
            .attr('y', function(d) { return(d[0]*cell_ht + 4*cell_ht + topmargin + 40)})
            .attr("width", cell_ht)
            .attr("height", cell_ht)
            .attr('stroke','#333')
            .attr('fill', function(d) {
              if (d[2] == 99) {
                return('black')
              } else if (d[2] == 0) {
                return('limegreen')
              } else {
                return(colorbrewer.OrRd[9][9-d[2]])
              }
            });

          vis.append("svg:text")
            .text('So when we are given a set of steps: "(down, right, down, ...)",')
            .attr('x', cell_ht*4+20)
            .attr('y', 4*cell_ht + topmargin + 40 + 16)
            .style('font-size', '16px')
            .style('fill', 'white');

          vis.append("svg:text")
            .text('we can reconstruct the most likely path.')
            .attr('x', cell_ht*4+20)
            .attr('y', 4*cell_ht + topmargin + 40 + 38)
            .style('font-size', '16px')
            .style('fill', 'white');

          vis.append("svg:text")
            .text('Click the circle to see the algorithm in action.')
            .attr('x', cell_ht*4+20)
            .attr('y', 4*cell_ht + topmargin + 40 + 60)
            .style('font-size', '16px')
            .style('fill', 'yellow');

          robot.enter()
              .append("svg:circle")
              .attr('class','robot')
              .attr("r", 6)
              .attr('cx', function(d) {return d[1] + cell_ht/2})
              .attr('cy', function(d) {return d[0] + cell_ht/2 + 4*cell_ht + topmargin + 40})
              .style("fill", 'lime')
              .style('stroke', 'green')
              .on('click', function() {
                json.forEach(function(move,idx) {
                  vis.selectAll('.robot').transition()
                    .delay(1000*idx)
                    .duration(1000)
                    .ease('linear')
                    .attr('cx', move[1]*cell_ht + cell_ht/2)
                    .attr('cy', move[0]*cell_ht + cell_ht/2 + 4*cell_ht + topmargin + 40)

                  setTimeout(function() {
                    speech_group.append("svg:image")
                       .attr('x',-75)
                       .attr('y',-20)
                       .attr('width', 600)
                       .attr('height', 200)
                       .attr("xlink:href","/images/terminator-2-robot.gif")
                  }, 1000*json.length)
                })
              })
      })
    })
  });

  var trellis_diagram = speech_group.append("svg:g").attr('id','trellis_diagram')
      .attr("transform", "translate(" + 0 + "," + 430 + ")");

  speech_group.append("svg:text")
              .text('Speech Recognition')
              .style('font-size','36px')
              .style('fill', 'white')
              .attr('y', 300)
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('A well-known application of HMMs and the viterbi algorithm is speech recognition.')
              .style('font-size','18px')
              .attr('y', 350)
              .style('fill', 'white')
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('If we observe the phones `n`,`iy`, and `t` we can use viterbi to determine the most likely word.')
              .style('font-size','18px')
              .attr('y', 374)
              .style('fill', 'white')
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('Click each state to see the forward transitions probability calculations.')
              .style('font-size','18px')
              .attr('y', 398)
              .style('fill', 'yellow')
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('phone 1: n')
              .style('font-size','18px')
              .attr('y', 457)
              .attr('x', 99)
              .style('fill', 'white')
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('2: iy')
              .style('font-size','18px')
              .attr('y', 457)
              .attr('x', 329)
              .style('fill', 'white')
              .style("fill-opacity", 1);

  speech_group.append("svg:text")
              .text('3: t')
              .style('font-size','18px')
              .attr('y', 457)
              .attr('x', 517)
              .style('fill', 'white')
              .style("fill-opacity", 1);

  d3.json("/js/dict.json", function(json) {
    root = json;
    root.x0 = h / 2;
    root.y0 = 0;
    function toggleAll(d) {
      if (d.children) {
        d.children.forEach(toggleAll);
        toggle(d);
      }
    }

    // Initialize the display to show a few nodes.
    root.children.forEach(toggleAll);

    update(root);
  });

  function update(source) {
    var duration = d3.event && d3.event.altKey ? 5000 : 500;

    // Compute the new tree layout.
    var nodes = tree.nodes(root).reverse();

    // Normalize for fixed-depth.
    nodes.forEach(function(d) { d.y = d.depth * 180; });

    // Update the nodes…
    var node = trellis_diagram.selectAll("g.node")
        .data(nodes, function(d) { return d.id || (d.id = ++i); });

    // Enter any new nodes at the parent's previous position.
    var nodeEnter = node.enter().append("svg:g")
        .attr("class", "node")
        .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
        .on("click", function(d) { 
          toggle(d);
          update(d); });

    nodeEnter.append("svg:circle")
        .attr("r", 1e-6)
        .style("fill", function(d) {
          if (d.value == 0.0) {
            return 'white'
          } else {
            return o(d.value)
          };
        });

    nodeEnter.append("svg:text")
        .attr("x", function(d) { return d.name == 'start' ? 10 : -10; })
        .attr("dy", ".35em")
        .attr("text-anchor", function(d) { return d.name == 'start' ? "start" : "end" ; })
        .text(function(d) { return d.name; })
        .style('fill', 'white')
        .style("fill-opacity", 1e-6);

    // Transition nodes to their new position.
    var nodeUpdate = node.transition()
        .duration(duration)
        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

    nodeUpdate.select("circle")
        .attr("r", 4.5)

    nodeUpdate.select("text")
        .style("fill-opacity", 1);

    // Transition exiting nodes to the parent's new position.
    var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
        .remove();

    nodeExit.select("circle")
        .attr("r", 1e-6);

    nodeExit.select("text")
        .style("fill-opacity", 1e-6);

    // Update the links…
    var link = trellis_diagram.selectAll("path.link")
        .data(tree.links(nodes), function(d) { return d.target.id; });

    // Enter any new links at the parent's previous position.
    link.enter().insert("svg:path", "g")
        .attr("class", "link")
        .attr("d", function(d) {
          var o = {x: source.x0, y: source.y0};
          return diagonal({source: o, target: o});
        })
      .transition()
        .duration(duration)
        .attr("d", diagonal);

    // Transition links to their new position.
    link.transition()
        .duration(duration)
        .attr("d", diagonal);

    // Transition exiting nodes to the parent's new position.
    link.exit().transition()
        .duration(duration)
        .attr("d", function(d) {
          var o = {x: source.x, y: source.y};
          return diagonal({source: o, target: o});
        })
        .remove();

    // Stash the old positions for transition.
    nodes.forEach(function(d) {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  // Toggle children.
  function toggle(d) {
    if (d.children) {
      d._children = d.children;
      d.children = null;
    } else {
      d.children = d._children;
      d._children = null;
    }
  }

</script>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/23/Conflict-Analysis-Project/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="abarciauskas-bgse.github.io">Aimee Barciauskas</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>